欧里几得扩展算法

> 辗转相除法：25/10=2......5   10/5=2......0     
>
> 传入两个数a，b  首先进行a/b，此时得出来余数a%b，第二次时的被除数变为上一次的除数，第二次时的除数变为上一次得出来的余数，按照过程进行递归，递归的出口为最后一次的余数为0，返回最后一次的除数即为这两个数的最大公约数。

```c++
核心代码：return b==0 ? a : gcd(a,b);
```

> ```
> 贝祖定理：若a，b是整数，且gcd(a,b)=d，那么对于任意的整数x，y，ax+by=m中的m一定是d的倍数。（特别地，如果a、b是整数，那么一定存在整数x、y使得ax+by=gcd(a,b)。）
> ```

扩展欧里几得的推导过程：

<img src="D:\桌面\新建文件夹\1710902948481.png" alt="1710902948481" style="zoom: 50%;" />

```
推导过程中x，y与x'，y'的解释：

递归边界：b==0，a=gcd(a,b) ，这时可以观察出来这个式子的一个解：a*1+b*0=gcd(a,b)，x=1,y=0，但是这时的a和b已经不是最开始的那个a和b了，所以我们如果想要求出解x和y，就要回到最开始的模样。

初步想法：由于是递归的算法，如果我们知道了这一层和上一层的关系，一层一层推下去，就可以推到最开始的。

假设当前我们在求的时a和b的最大公约数，而我们已经求出了下一个状态：b和a%b的最大公因数，并且求出了一组x1和y1使得 b*x'+(a%b)*y'=gcd（注意在递归算法中，永远都是先得到下面一个状态的值）

这时我们可以试着去寻找这两个相邻状态的关系：由上面的推导可以看出 x = y' , y = x' – a/b*y'这样我们就得到了每两个相邻状态的x和y的转化，就可以在求gcd的同时对x和y进行求值了
```

```
【问题描述】
给定 n 对正整数 ai,bi，对于每对数，求出一组 xi,yi，使其满足 ai×xi+bi×yi=gcd(ai,bi)。
【输入格式】第一行包含整数 n。 接下来 n 行，每行包含两个整数 ai,bi。
【输出格式】输出共 n 行，对于每组 ai,bi，求出一组满足条件的 xi,yi，每组结果占一行。本题答案不唯一，输出任意满足条件的 xi,yi 均可。
【数据范围】1≤n≤10^5, 1≤ai,bi≤2×10^9
```

```c++
#include <bits/stdc++.h>
using namespace std;
 
void exGCD(int a,int b,int &x,int &y) {
    if(b==0) x=1,y=0;
    else {
        exGCD(b,a%b,x,y);
        int temp=y;
        y=x-a/b*y;
        x=temp;
    }
    return;
}
 
int main() {
    int n;
    cin>>n;
    while(n--) {
        int a,b,x,y;
        cin>>a>>b;
        x=a,y=b;
        exGCD(a,b,x,y);
        cout<<x<<" "<<y<<endl;
    }
 
    return 0;
}
 
/*
in:
2
35 25
25 10
out:
-2 3
1 -2
*/
```

