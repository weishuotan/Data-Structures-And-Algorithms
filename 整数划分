对于一个大于2的整数n，要求仅使用2的若干次幂的整数集合进行划分，使得集合中所有整数之和等于n，问可以有多少种划分？
1:(1) →(1种)
2:(1,1),(2) →(2种)
3:(1,1,1),(1,2) →(2种)
4: (1,1,1,1),(1,1,2),(2,2),(4) →(4种)
5:(1,1,1,1,1),(1,1,1,2),(1,2,2),(1,4) →(4种)
6:(1,1,1,1,1,1),(1,1,1,1,2),(1,1,2,2),(1,1,4),(2,2,2),(2,4) →(6种)
7: (1,1,1,1,1,1,1),(1,1,1,1,1,2),(1,1,1,2,2),(1,1,1,4),(1,2,2,2),(1,2,4) →(6种)
#include <bits/stdc++.h>
using namespace std;
const int maxn=1000;
int d[maxn];

int divide(int n){
    d[1]=1;
    d[2]=2;
    int i;
    for(i=3;i<=n;i++){
        if(i%2!=0) d[i]=d[i-1];
        else d[i]=d[i-1]+d[i/2];
    }
    return d[n];
}

int main() {
    int n;
    scanf("%d",&n);
    printf("%d",divide(n));
    
    return 0;
}
